---
title: "Page Load Analysis\nBlinkOn 8"
author: "tdresser@chromium.org"
date: "September 14, 2017"
output: 
  slidy_presentation:
    widescreen: true
    fig_width: 10
    fig_height: 4.5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE)
options(scipen=10000)
knitr::opts_knit$set(verbose=TRUE)
source('main.R')
source('per_second.R')
```

## Goal of this talk
* Convince you to invest in large scale lab based performance analysis.
* Dig into some data.

## Overall Distribution

```{r, echo=FALSE, warning=FALSE}
plot_totals_jitter +
  theme(strip.text.x = element_text(size = 7),
        strip.text.y = element_text(size = 7))
```

## Overall Distribution (Sampled)
```{r, echo=FALSE, warning=FALSE}
ggplotly(plot_totals_jitter_sampled +
  theme(strip.text.x = element_text(size = 7),
        strip.text.y = element_text(size = 7)), tooltip="text")
```

## Objective of this analysis.
* Find Chrome and Website bugs based on new insight.
* Understand Page Load performance at scale.
* Identify weaknesses in our metrics.

## Gathering Data
* Load the Alexa top 10k on Nexus 5's.
* Simulate 3G network.
* Both warm & cold Page loads.
* Reasonably detailed main thread attribution.

## Time To Consistently Interactive

```{r echo=FALSE, warning=FALSE}
ggplotly(plot_ci_warm_vs_cold, tooltip="text")
```

## Time To Consistently Interactive | Quantiles
```{r echo=FALSE, warning=FALSE}
ggplotly(plot_ci, tooltip = "text")
```

## Time To Consistently Interactive | Normalized by quantiles
```{r echo=FALSE, warning=FALSE}
ggplotly(plot_ci_normalized, tooltip="text")
```

## Important Timestamp Deltas
```{r echo=FALSE, warning=FALSE}
ggplotly(plot_important_times + 
           theme(strip.text.y = element_text(size = 7),
                 axis.text.x = element_text(size = 6)), tooltip="text") 
```

## Per Second Contributors
```{r echo=FALSE, warning=FALSE}
ggplotly(plot_per_second, tooltip="text")
```

## Next Steps: Elimate Other
* [Issue](https://github.com/catapult-project/catapult/issues/3864).
* Some [low hanging fruit](https://gist.github.com/deepanjanroy/84788dee9be12b01502a1708daf135da):

```
Slice Title: Total self time in ms across top 10k pages
TaskQueueManager::RunTask : 45799357.7984
LocalFrameView::prePaint : 22831219.588
ProxyMain::BeginMainFrame::commit : 16157595.614
TaskQueueManager::ProcessTaskFromWorkQueue : 16034099.1022
V8.NewContext : 15784434.0443
```

## Next Steps: Elimate Other
* We need some better ways to keep trace event renaming from breaking metrics.
* Contribute by adding your slices to the [user friendly category driver.](https://cs.chromium.org/chromium/src/third_party/catapult/tracing/tracing/extras/chrome/chrome_user_friendly_category_driver.html)
```javascript
const TITLES_FOR_USER_FRIENDLY_CATEGORY = {
    composite: [
      'CompositingInputsUpdater::update',
      'ThreadProxy::SetNeedsUpdateLayers',
      'LayerTreeHost::UpdateLayers::CalcDrawProps',
      'UpdateLayerTree'
    ]
}
```

## Next Steps: Improved Breakdowns
* blocked\_on\_network should split out by type of resource.
* Can script\_execute be split out via runtimeCallStats?
* Filter out 404s - maybe pick a better pageset?
* ???

## Next Steps: Crazy Ideas
* Label sites by framework.
* Gather memory data as well.
* Do the same thing, but for input.